#include <cstdio>
#include <iostream>
#include <set>
#include <map>
#include <stack>

#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IRReader/IRReader.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/Constants.h"

using namespace llvm;

static LLVMContext MyGlobalContext;

std::set<Instruction*> findInitializedVars(BasicBlock*,std::set<Instruction*>);
std::set<Instruction*> intersect_sets(std::set<Instruction*>, std::set<Instruction*>);
std::set<Instruction*> union_sets(std::set<Instruction*> A, std::set<Instruction*> B);
void printAnalysisMap(std::map<std::string,std::set<Instruction*>> analysisMap);
bool isInitialized(llvm::Value *val, std::set<Instruction*> init);
std::string getSimpleNodeLabel(const BasicBlock *Node);
int main(int argc, char **argv)
{
    // Read the IR file.
    LLVMContext &Context = MyGlobalContext; //A reference to the core LLVM "engine" that you should pass to the various methods that require a LLVMContext.
    SMDiagnostic Err;
    
    // Extract Module M from IR (assuming only one Module exists)
    // Modules are the top level container of all other LLVM Intermediate Representation (IR) objects.
    std::unique_ptr<Module> M = parseIRFile(argv[1], Err, Context);
    if (M == nullptr)
    {
      fprintf(stderr, "error: failed to load LLVM IR file \"%s\"", argv[1]);
      return EXIT_FAILURE;
    }

    // 1.Extract Function main from Module M
    Function *F =M->getFunction("main");
    
    // 2.Define analysisMap as a mapping of basic block labels to empty set (of instructions):
    // For example: Assume the input LLVM IR has 4 basic blocks, the map
    // would look like the following:
    // entry -> {}
    // if.then -> {}
    // if.else -> {}
    // if.end -> {}        
    std::map<std::string,std::set<Instruction*>> analysisMap;
    for (auto &BB: *F){
	std::set<Instruction*> emptySet;
    	analysisMap[getSimpleNodeLabel(&BB)] = emptySet;
    }      
    // Note: All variables are of type "alloca" instructions. Ex.
    // Variable a: %a = alloca i32, align 4

    // 3. Traversing the CFG in Depth First Order
    // In order to do so, we use a stack: traversalStack.
    // First, we add the initial analysisNode consisting of the following two items to the stack:
    // 	    - entry basic block 
    //	    - an empty set (of instructions) as the initial list of initialized variables
    std::stack<std::pair<BasicBlock*,std::set<Instruction*> > > traversalStack;
    BasicBlock* entryBB = &F->getEntryBlock();
    std::set<Instruction*> emptySet;
    std::pair<BasicBlock*,std::set<Instruction*> > analysisNode = std::make_pair(entryBB,emptySet);
    traversalStack.push(analysisNode);
    
	// errs() << "Adding to the stack:\n\t" << getSimpleNodeLabel(entryBB) << ": \n";
	// for (Instruction* var : emptySet){
	// 	errs() << "\t";
	// 	var->dump();
	// }
	//errs() << "\n";

    // 4. while the stack is not empty we pop the top analysisNode
    // An updated analysis (list of initialized vars) is generated by running the findInitializedVars on the analysisNode
    // The updated list of initialized vars is intersected with the current list of initialized vars for the basic block in the
    // analysis Map
    // Finally, the successor nodes of the current basic block with the updated list of initialized vars is added to the stack
    // Extract updatedInitializedVars (The list of initialized variables after BB) from BB and initializedVars
    // from it, and then we add all its successors to it    
    while(!traversalStack.empty()){
	//printAnalysisMap(analysisMap);
        // Pop the top analysis node from stack
        std::pair<BasicBlock*,std::set<Instruction*> > analysisNode = traversalStack.top();
       	traversalStack.pop();
       	
	    // Extract the basic block and the set of initialized variables from  analysisNode
	    BasicBlock* BB = analysisNode.first;
      	std::set<Instruction*> entryInitializedVars = analysisNode.second;
      	errs() <<  "Analyzing Node " << getSimpleNodeLabel(BB) <<  "\n\n";

        // Extract updatedInitializedVars (The list of initialized variables 
	    // after BB) from BB and initializedVars
        std::set<Instruction*> updatedInitializedVars = findInitializedVars(BB,entryInitializedVars);
        
        // Update the analysis of node BB in the MAP to the interesection of currently stored InitializedVars
        // and the generated updatedInitializedVars
        std::set<Instruction*> exitInitializedVars;
        if (analysisMap[getSimpleNodeLabel(BB)].empty()){
        	exitInitializedVars = updatedInitializedVars;
        }else {
        	exitInitializedVars = intersect_sets(analysisMap[getSimpleNodeLabel(BB)],updatedInitializedVars);
        }
    	analysisMap[getSimpleNodeLabel(BB)] = exitInitializedVars ;

        // Extract the last instruction in the stack (Terminator Instruction)
        const auto *TInst = BB->getTerminator();
        
	    // Extract the number of successors the terminator instructor has
	    int NSucc = TInst->getNumSuccessors();
	
	    for (int i = 0;  i < NSucc; ++i) {
            // for all successor basic blocks, add them plus the updatedInitializedVars to the stack 
            // Add the current stored analysis for a successor node
            BasicBlock *Succ = TInst->getSuccessor(i);    
            //std::set<Instruction*> succInitializedVars = analysisMap[Succ->getName()];
           	std::pair<BasicBlock*,std::set<Instruction*> > succAnalysisNode = std::make_pair(Succ,exitInitializedVars);
           	traversalStack.push(succAnalysisNode);

           	std::string BBLabel = getSimpleNodeLabel(Succ);
        	errs() << "Adding to the stack:\n\t" << BBLabel << ": \n";
        	for (Instruction* var : exitInitializedVars){
        		errs() << "\t";
        		var->print(errs(), nullptr);
        	}
        	errs() << "\n";

            // Fixpoint Condition:
            // We only add successor nodes to the stack if the intersection of the new list of initialzied variables for
            // the successor node is different from the currently stored list of initialzied variables
            // for the successor node.

           	// TO BE COMPLETED
    	}	
    }
    

    printAnalysisMap(analysisMap);

    return 0;
}

// Input Arguments:
// BB: current Basic Block  
// initializedVars: The list of initialized vars before BB
// 
// Output:
// updatedInitializedVars: The list of initialized variables after BB
//
// This function receives a list of initialized variables before a basic block
// and returns an updated list of initialized variables after the basic block
std::set<Instruction*> findInitializedVars(BasicBlock* BB,
				    std::set<Instruction*> initializedVars)
{
  // updatedInitializedVars is first initialized to the current list
  // of initialized variables 
  std::set<Instruction*> updatedInitializedVars(initializedVars);
  
  // Loop through instructions in BB
  for (auto &I: *BB)
  {
    // Check if an Instruction is of the type Store Instruction
    // We assume variables are only initialized if they are 
    // assigned a value by the StoreInst.
    if (isa<StoreInst>(I)){
      // A Store Instruction is of the type:
      // Store Arg0, Arg1 
      // Where Arg0 is a %reg and Arg1 is a %variable.
      // We need to store the %variable since it is initialized 
      // e.g., store i32 5, i32* %c, align 4      
      // store i32 %1, i32* %e, align 4

      // We load Arg1 to an instance of the class Value 
      // Note: All instructions and arguments are instaces of the Value class
      Value* v = I.getOperand(1);
      
      // Next we convert the instance of Value class to a variable
      // Note: All variables are of type "alloca" instructions. Ex.
      // Variable a: %a = alloca i32, align 4
      Instruction* var = dyn_cast<Instruction>(v);

      Value* arg = I.getOperand(0);
      if(isInitialized(I.getOperand(0), updatedInitializedVars)){
          // Finally, var is added to updatedInitializedVars
          updatedInitializedVars.insert(var);	// Gen
      } else {
    	  updatedInitializedVars.erase(var);	// kill
      }
    }
  }
  return updatedInitializedVars;
}

// Performs set intersection
std::set<Instruction*> intersect_sets(std::set<Instruction*>A, std::set<Instruction*> B)
{
	std::set<Instruction*> result;
	std::set_intersection(A.begin(), A.end(), B.begin(), B.end(),
			std::inserter(result,result.begin()));
     return result;
}

// Performs set union
std::set<Instruction*> union_sets(std::set<Instruction*>A, std::set<Instruction*> B)
{
     A.insert(B.cbegin(), B.cend());
     return A;
}



// Printing Basic Block Label
std::string getSimpleNodeLabel(const BasicBlock *Node) {
    if (!Node->getName().empty()){
	errs()<<Node->getName().str();
        return Node->getName().str();}
    std::string Str;
    raw_string_ostream OS(Str);
    Node->printAsOperand(OS, false);
    return OS.str();
}

// Printing Analysis Map
// When we exit the loop the analysis have finished and the analysis map will point to the set of
// initialized instructions at each basic block. Ex.
// entry -> {%a = alloca i32, align 4}
// if.then -> {%a = alloca i32, align 4}
// if.else -> {}
// if.end -> {%a = alloca i32, align 4, %b = alloca i32, align 4}
void printAnalysisMap(std::map<std::string,std::set<Instruction*>> analysisMap) {
	errs() << "PRINTING ANALYSIS MAP:\n";
    for (auto& row : analysisMap){
    	std::set<Instruction*> initializedVars = row.second;
    	std::string BBLabel = row.first;
    	errs() << BBLabel << ":\n";
    	for (Instruction* var : initializedVars){
    		errs() << "\t";
    		var->print(errs(), nullptr);
    	}
    	errs() << "\n";
    }
}

bool isInitialized(llvm::Value *val, std::set<Instruction*> init) {
	  if (isa<llvm::ConstantInt>(val)
	    || isa<llvm::ConstantFP>(val)
		|| isa<llvm::ConstantExpr>(val)
		|| isa<llvm::GlobalValue>(val)) {
	    return true;
	  } else if (isa<llvm::LoadInst>(val)) {
	    llvm::LoadInst *inst = dyn_cast<llvm::LoadInst>(val);
	    return isInitialized(inst->getOperand(0), init);
	  } else if (isa<llvm::BinaryOperator>(val)) {
	    llvm::BinaryOperator *inst = dyn_cast<llvm::BinaryOperator>(val);
		bool left = isInitialized(inst->getOperand(0), init);
		bool right = isInitialized(inst->getOperand(1), init);
	    return left & right;
	  } else if (llvm::isa<llvm::AllocaInst>(val)) {
		  llvm::Instruction *inst = dyn_cast<llvm::Instruction>(val);
		  return (init.count(inst) != 0);
	  } else {
		  return false;
	  }
}
